# 汇编语言

## 第一章 基础知识

1. 机器语言的核心是机器指令集，而不同CPU(微处理器)由于硬件等的不同，会对应有不同的机器指令集，即在表达含义相同的情况下，映射出的机器码却不同(方言)，因此，汇编语言(汇编指令/伪指令/其他符号) [核心是汇编指令集] 其实是对机器语言的向上一层抽象，通过汇编编译器与机器码相关联 [是如何对应起来的呢？？]  
2. 内存(存储器，由若干存储单元 [8位二进制位] 组成)与CPU通过"指令" "数据"(本质都是二进制信息，可以有不同的解释方式)进行交互，磁盘通过内存与CPU交互  
3. B KB MB GB TB  
4. CPU(物理上二者之间还有"管脚")通过总线(地址总线 [其宽度表征CPU的寻址能力] /控制总线 [其宽度表征CPU的控制能力] /数据总线 [其宽度表征CPU同外部器件一次传输的数据量的大小] )与外部各个器件相交互，例如对于存储器，先通过地址总线定位到具体的存储单元的地址进行待定，再通过控制总线告诉存储器芯片将要读/写，总后经由数据总线写入/读出数据  
5. 主板上有不同的器件(接口卡与拓展卡槽/各类存储器芯片)，对于CPU，可以将这些器件抽象(想象)统一成一块逻辑存储器(即是内存地址空间，囿于CPU地址总线的宽度)，不同器件(物理存储器)占有不同的地址空间(范围不同)  

## 第二章 寄存器

1. 本章深入CPU(寄存器/运算器/控制器/内部总线)内部，着重讲述了多种寄存器  
2. AX/BX/CX/DX是四种通用寄存器，存储一般性的数据，可单独分为低八位(AL/BL/CL/DL)/高八位(AH/BH/CH/DH)两个寄存器来使用，字在寄存器中占两个字节  
3. mov/add指令  
4. CS [CS/DS/SS/ES四个段寄存器中的一个，提供段地址] /IP [指令指针寄存器，提供偏移地址] 是CPU中两个最关键的、与指令有关的寄存器(16位寄存器，其传出地址所指向的存储单元里的信息一定按"指令"解释 [8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行，CPU只认被CS:IP指向的内存单元中的内容为指令])；CPU外部的地址总线是20位的，而CPU的内部总线是16位的，那么如何将16位的地址转换为20位的物理地址呢？ [不同CPU可以有不同的形成物理地址的方式，以下仅对于8086CPU] CS/IP经由16位内部总线将地址发出，到达地址加法器后经过"段地址 x 16 + 偏移地址 = 物理地址"等运算即可完成转换，最后经由20位总线到达输入输出控制电路向外输出，"段地址 x 16"所得也可称为"起始/基础地址"，任何一个内存单元的物理地址用该公式都可以有不同的表示方式，可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段；在第一章中提及过，地址总线的宽度表征了CPU的寻址能力，在学习完本章后，我认为，对于CPU寻址能力更本质的解释，应该是由偏移地址所决定，即由IP(8086CPU的IP是16位，因此最多可以寻址64KB)决定  
5. 了解8086CPU读取、执行指令的工作原理，涉及到指令缓冲器、执行控制器等等  
6. 在CPU中，程序员能够用指令读写的部件只有寄存器，可以通过改写寄存器中的内容实现对CPU的控制；对于8086CPU大部分寄存器中的值都可以用mov指令(传送指令)来改变，除了CS/IP，能改变CS/IP内容的指令被统称为转移指令，比如jmp指令，学会用jmp指令改变CS/IP中的内容  
7. 实验1：学会用DEBUG程序，掌握DEBUG程序里的R/D/E/U/T/A命令  

## 第三章 寄存器(内存访问)

1. CS(CodeString): 与IP配合，指向代码段/指令段；DS(DataString): 与[……]配合，指向数据段；SS(StackString): 与SP配合，指向栈段；注意理解段  
2. 8086CPU内部总线为16位，一次性传一个字型数据 [只要MOV指令的操作对象是16位的寄存器即可] ，注意"低位字节 高位字节 字单元 N地址字单元"等概念  
3. 注意mov/add/sub指令的操作对象(数据/内存单元/寄存器/段寄存器)  
4. 栈也是内存的一部分，只不过是以特殊的方式访问，CPU不管栈顶越界的问题，需要程序员自己注意  
5. 注意CPU提供的栈机制以及PUSH/POP指令的实际操作/本质及与MOV指令的异同  
6. 实验2：DEBUG的T命令在执行修改栈段寄存器SS的指令时，下一条指令也紧接着被执行  

## 第四章 第一个程序

1. 本章深入讲解了从一个.ASM/.TXT文件到.EXE文件并执行的全过程  
2. 理解一个汇编语言程序从写出到执行的全过程，注意"目标文件 可执行文件 源程序 程序 伪指令 标号[代表一个地址，这个地址处可能有指令/数据] 程序返回 语法错误 逻辑错误"等概念，注意可执行文件包含的内容/一个汇编程序的组成/编译和连接等过程  
3. 注意Shell，command.com，其他程序 [DEBUG/command/……] 加载可执行文件中程序的过程
4. 能利用DEBUG跟踪程序执行的过程，留意CX寄存器(存有程序的长度)/"(DS) + 10H = (CS)"  
5. 利用编辑器生成.ASM/TXT文件，保存有汇编语言源程序，源程序中最后真正要用到的指令、数据等称为程序，用汇编编译程序将文本文件编译为.OBJ目标文件，再用连接程序将.OBJ文件同其余目标文件或是用到了子程序的库连接起来，生成.EXE可执行文件，内含程序和数据以及相关描述信息；在执行时，DOS环境下的command(SHELL程序)根据可执行文件里的描述信息找到一块内存区，创建PSP，从256字节处开始存放程序，再将该内存区的段地址存入DS中，初始化其他寄存器后，比如CX中存有程序长度，设置CS:IP指向程序入口，command暂停运行，CPU根据CS:IP的指向开始运行程序，运行完毕后返回command，CPU继续运行command，命令行提示符后等待用户的下一次输入
6. 可执行文件中的程序执行过程：  
   - 由其他程序将可执行文件中的程序加载入内存  
   - 设置CS:IP指向程序的第一条要执行的指令(即程序的入口)，从而使程序得以运行  
   - 程序运行结束后，返回到加载者  

## 第五章 [BX]和loop指令

1. 相较于之前 [1]/[2]/…… 这样 [idata] 的方式，[BX]则更为灵活些，可用于变量，只需要改变BX寄存器中的值即可；loop指令显然与循环相关  
2. 注意DEBUG程序和汇编编译器masm等对指令的不同处理/不同解释方式  
3. 注意描述一个内存单元需要的两种信息，loop指令的实现(通过标号)及与[BX]的联合应用，跳过循环的两种方式 [CX寄存器存放循环次数，t/p/g命令] ，"段前缀"及其使用  
4. 注意DOS实模式和保护模式，以及在任何模式下一段比较安全的空间  

## 第六章 包含多个段的程序  

1. 学习完本章，加载到内存里的程序的结构更完善了，加载者从可执行文件的描述信息中读取程序的入口地址("end 标号"中标号最终被转化成的地址)，设置CS:IP，在这块内存区的最前端是PSP，后面是代码段/数据段/栈段，DS存放有内存区最前端(PSP)的段地址，DS+10H是PSP后第一个段的段地址，CS/DS/SS分别指向这三个段  
2. 学会在代码段中使用栈/数据，学会将数据/代码/栈放入不同的段  
3. 实验5：
   - 源程序被加载进内存后，PSP后是数据段/栈段/代码段，在物理地址上这三个段是连续的，但是由于被分为三个段，段地址必定是不同的  
   - 如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 [(N/16+1)*16] ，即分配的空间一定是16的倍数且大于等于段中数据的字节数(可能会多分配，留意SP栈顶指针的初始化) [程序长度=代码段中的代码长度+数据段长度+栈段长度(由上可知后两个都会补成16的整数倍，代码段按理应该也会补，但是实际上观察CX中存放的程序长度会发现并不是16的整数倍，可能是因为栈段和数据段中补的空间是程序执行时实际可用的，而代码段中补的00机器码并不能直接执行，因此最后是与代码段中的代码长度相加)]  
   - 程序段如果不在最前，必须指定程序入口，否则会把栈段/数据段里本来打算解释成数据等的内容当作指令来解释执行  

## 第七章 更灵活的定位内存地址的方法

1. 如题目所示，本章着重讲述了几种定位内存地址的方法(第八章有更全面的总结)  
   - [idata]：一个常量
   - [BX]：一个变量
   - [BX/SI/DI+idata]：一个变量+一个常量
   - [BX+SI/DI]：两个变量
   - [BX+SI/DI+idata]：一个常量+两个变量  
        - 选取原则：根据题目分析需要几个常量几个变量，按需选取  
        - 注意指令还有其他书写格式，比如 ***mov ax,[200+bx]/mov ax,200[bx]/mov ax,[bx].200***
2. SI/DI寄存器：同BX，但是不能当成两个8位寄存器使用；AND/OR指令  
3. 注意二重循环问题的处理  
4. 栈的一个应用：一般来说，在需要暂存数据的时候，应该使用栈，注意分析原因  
5. 注意大小写转化的方法(2种)  
6. 一点联系：  
   - 在汇编语言里，以字符形式给出数据的方式 ***db 'unIx'*** 与C语言里的 ***'u'*** 形似，字符都用单引号括住，编译器将其转化为相应的ASCII码  
   - 对于定位字符串中字符的方式，C语言是 ***a[i]/b[i] a+i/b+i*** ，汇编语言可以是 ***0[bx]/5[bx] idata+bx*** ，而a/b等变量名其实就是地址，[bx+idata]的方式为高级原因实现数组提供了便利机制  

## 第八章 数据处理的两个基本问题

1. 注意BX/SI/DI/BP寄存器的使用，机器指令处理的数据在什么地方，汇编语言中数据位置的表达，寻址方式，指令要处理数据的长度  
2. 注意div指令/伪指令dd/dup的使用  
3. 实验7：学会在结构化数据中灵活应用寻址方式来访问，比如 [bx].idata/[bx].idata[si] ，搞清楚bx/idata/si分别指什么  

## 第九章 转移指令的原理

1. 关于P186页的"浮动装配"问题:  
   > "http://www.asmedu.net/bbs/pasteinfo.jsp?part=1&level=book&kind=1010&qkSg=2&qID=44919&readSg=1" 这个帖子有在讨论，也就是说根据位移进行转移的意义是方便了同一程序段在内存中的浮动装配，可能与操作系统的相关知识有关，想象一段程序，其中的 loop s 转换成机器码后若含有的是s的地址(假设是20000H)而不是位移，现在要将这段程序保存到外存，于是对该程序段进行"快照"并存起来，但是再次将该程序段转移到内存时，可能就不在原地址处了 [突然想到，要是在一个函数里调用另一个函数，会将现在进行到的地址保存起来，待被调用函数执行完毕后据此返回到原来的地址处；但这两个是不同层面的问题，也不太相关，在函数里保存原地址并且返回到原地址是因为要继续往下执行，但是"浮动装配"问题并不需要继续向下执行，ta可能转移的是一个整体，再次返回内存时随机分配一段内存即可，并不一定需要返回到原地址处] 此时的s可能是10000H，但是loop s还是上次的loop 20000H，显然，s处的指令不在目的地址处，程序的执行就会出错；但是如果loop s的机器码中保存的是位移就不会有这个问题了，因为相对的地址总是不会变的。一言以蔽之，同一程序可能并不是只加载一次到内存里  
2. 注意转移指令的含义和多种分类(loop/jcxz指令等)，操作符offset，nop: 占据一个字节，机器码/值为90H  
3. 注意jmp指令的分类：
   - 依据位移进行转移的(想想位移为什么是减去jmp指令**后**的第一个字节的地址)  
   - 转移的目的地址在指令中的  
   - 转移地址在寄存器中的  
   - 转移地址在内存中的  
4. 编译器会对转移位移超界进行检测，根据short/near/far划定转移范围作为检测标准  
5. 实验9：学会向B8000H-BFFFFH共32KB的80*25彩色字符模式的显示缓冲区空间写入内容  

## 第十章 CALL和RET指令

1. 注意ret/retf指令及其实现机制(通过出栈操作改变IP/CS&IP)，注意call指令及其实现机制(将IP/CS&IP压栈+jmp指令，但是不能短转移)，call与ret/retf配合即可实现子程序(函数)的机制/模块化设计  
2. 注意mul指令的使用  
3. 子程序的注释信息应该包含对子程序的功能、参数和结果的说明  
4. 迫于寄存器数量的有限，对于批量数据/返回结果的传递，可以将其放到内存里，然后将所在内存空间的首地址放在寄存器中，再传递给需要的子程序。这种思想在其他高级语言上也可以找到佐证，比如C语言里很少将数组直接传递到函数中，而是把首元素指针传进去，数组其实就是连续的内存单元，而那个指针自然也就是该段空间的首地址了  
5. 迫于寄存器数量的有限，在主程序以及调用的子程序里可能要用到同一个寄存器，对于寄存器冲突的问题，解决办法同call指令的实现机制差不多，在子程序的开始将子程序中所有用到的寄存器中的内容都压到栈中保存起来，在子程序返回前再恢复。此时的栈里应该会有CS/IP/其他寄存器里的内容等，高级语言里的函数调用栈与此相似  
6. 实验10：  
   - 注意jcxz指令与loop指令不要混用了，二者都与CX寄存器相关，一个判断是否为0，一个减一，混用会出错  
   - 在解决除法溢出时，要用到公式：*X/N=int(H/N)x65536+[rem(H/N)x65536+L]/N*，具体可见P208页及附注5，注意该公式的含义，先是X的高16位与N相除，所得商即为最终结果的高16位，所得余数向右移16位再与X低16位相加，再除以N，所得商为最终结果的低16位，所得余数为最终结果的余数  
   - 形如"mov [……],0"是错的，Operand must have size，编译器不知道你要给那个内存单元多少0  

## 程序设计 1

1. call与ret配合使用时，自动会把IP/CS&IP里的内容压栈和出栈(实现机制)，同时为了避免寄存器冲突，你也需要把寄存器里的内容压栈和出栈，前者是隐式地自动地，后者则需要你去选择push/pop哪几个寄存器，因此一定一定要注意自己push/pop寄存器的时机，否则可能在ret之后回不到原来的地方了！！！原因可能就是你选择push/pop的时机不对，导致执行ret指令时，隐式自动pop进IP/CS&IP里的是某一个寄存器里的内容，而不是原先保存过的，自然就跳到某一个奇怪的地方了  
2. 不要在现有的主程序里随意使用自己曾写过的子程序(函数)，除非你有把握这个函数与现有主程序是百分百贴合的:)  

## 第十一章 标志寄存器

1. 注意了解标志寄存器及其bit位上各个标志的含义 [ZF/PF/SF/CF/OF/DF标志]，注意会影响标志寄存器的指令，例如运算指令，而传送指令大都不会影响  
   > 有时候用inc指令而不是add指令是因为inc和loop指令不会影响CF位  
2. 注意adc/sbb指令的用途，可对任意大的数据进行加法/减法运算  
3. 注意cmp指令的使用，[结果存到了CPU内的暂存器里] 使用后若想得知逻辑上真正结果的正负而不是实际结果，应同时考查sf位(得知实际结果的正负)及of位(得知有没有溢出)  
   > sf/of的值与逻辑上结果的正负的分析可见"https://blog.csdn.net/weixin_34275734/article/details/91377321"  
4. 类似于call与ret指令的配合使用，cmp指令通常和条件转移指令[je/jne/jb/jnb/ja/jna]配合使用以达到类似于高级语言里IF语句的效果  
   > 前面学习过的jcxz指令也是条件转移指令，ta会检测CX寄存器中的值来决定是否修改IP，而上述的je等条件转移指令会检测标志寄存器里的相关标志位来决定是否跳转，因此可以说上述指令所表现出来的逻辑含义(等于则转移/不等于则转移)是通过和cmp指令配合使用来体现的，当然不用cmp也可，只要检测到某个标志位符合变化了也会发生转移  
5. 注意DF标志位及串传送指令("字符串"传送，当然也可以是一大段程序的传送，此时的"程序"应当被解释成数据而不是真正的"程序"了)，利用"rep movsb/movsw"配合完成对字符(串)的循环复制转移，通过cld(clear direction)/std(set direction)指令可以改变DF位以达到正向or逆向传送  
6. 注意pushf/popf指令的使用，为直接访问标志寄存器提供了一种方法  
7. 注意标志寄存器在DEBUG中的表示，可参考如下助记法  
   ![~~你这么强就不需要助记了~~](../../../assembly/flag_in_DEBUG.png)  

## 第十二章 内中断

1. 注意理清中断的全过程，从中断源产生的中断信息 [对几个具有先后顺序の硬件操作所产生的事件的统一描述，是要求CPU马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息] 中可以得到中断类型码 [标识中断类型的来源] ，根据此码对应着中断向量表找到中断处理程序(中断例程)开始执行，之后用IRET恢复现场(同call与ret的配合相似，与硬件自动完成的中断过程配合使用，多了标志寄存器的参与)，通过"mov ax, 4c00H/int 21H"直接回到DOS中，其中需注意中断过程(自动进行，程序员无法改变)的具体流程以及中断例程的编写方法/框架  
2. 1号中断(aka单步中断)是通过每次指令执行完毕后检测TF位是否为1来进行的，注意与DEBUG的T命令的实现机制联系起来，[在DEBUG下输入T命令，DEBUG.EXE将TF位置为1，接着执行下一条指令，将指令从内存读到CPU内的指令缓冲器里，IP加上指令长度进而指向下一条指令后再执行该指令，执行完毕CPU检查TF位是否为1，若是1则引发中断过程，执行相应中断例程] 也解释了在中断过程中给TF位赋0的原因，[不赋0则在执行中断例程的指令时一直是1，显然会陷入死循环，一直只能执行例程的第一条指令，赋0的话执行完全部就直接出去了]  
   > 前面提及中断类型码是从中断信息中得到的，所以对于单步中断来说，TF标志位的值就是中断信息的一部分ma?还有下一章中的"int n"，n作为字节型立即数即为中断类型码，好像对于ta也不需要什么中断信息了，直接提供给CPU了  
3. 注意有些情况即便发生中断CPU也不会发生响应，例如CPU在执行设置ss的指令后不会响应中断，注意分析其原因及好处 [中断过程会将现场压入栈中，但是只设置了ss，总不能乱压吧，~~疯狂暗示~~]  
4. 实验12：学会改写中断例程，学会编写安装程序；注意到DOSBOX模拟出来的虚拟环境下，拿零号中断来讲，根据中断向量表相应的表项找到中断处理程序后发现是???，具体表现出来就是运行.exe后会一直运行下去；在DEBUG里用a命令编写完后，再用t命令一条条执行，单步调试后发现会陷入死循环，应该是提供的虚拟环境里的中断向量表对应的中断例程里结尾有IRET的缘故；而将该实验编写的0号中断处理程序加载进内存并改写中断向量表表项后，运行即可得到预期结果，因为程序结尾是"mov ax, 4c00H/int 21H"，运行至此即可返回DOS  

## 第十三章 int指令

1. 本章继续讲述第三种中断源，注意int与call相似，都是调用一段程序，同时注意其区别  
   > "一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用"  
2. 注意对int/iret/栈的深入理解，注意通过IRET&栈的机制对loop指令的巧妙实现，再去实现jmp就是少了cx的loop了
3. BIOS&DOS都提供相关中断例程(赠品)，但是BIOS是每个硬件生产厂商提供的，而DOS作为操作系统是像微软这样的软件公司提供的，"和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程"  
4. ~~这些赠品~~BIOS&DOS提供的一个中断例程往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序(你品……)，比如都用ah来传递内部子程序的编号，拿"int 10H"来讲，ta是BIOS提供的与屏幕输出相关的例程，有点像类，其中包含有多种方法，都给你封装了起来，对外提供接口(你传递的参数)，且都与屏幕输出相关；本节提供的一个BIOS中断例程应用是往屏幕上输出花里胡哨的a，之前肯定是"mov ax, 0b800H/……"，现在直接用"int 10H"，辅以借寄存器传递的参数即可简单实现，注意体会思想  
5. 注意BIOS的存放位置及内容，注意BIOS&DOS提供的资源是如何加载/安装进内存里的(十分的amazing，再往下就涉及操作系统了)
   > "https://illbnm.github.io/2019/04/11/BIOS%E5%90%AF%E5%8A%A8%E5%B9%B6%E5%8A%A0%E8%BD%BDOS/"  
6. 注意"mov ax, 4c00H/int 21H"作为DOS中断例程应用的真正含义  
7. 实验13：在使用DOS提供的第21H号例程的在光标位置显示字符串的功能时，要显示的字符串记得用'$'作为结束符，而不是以往的'0'，~~不愧是资本主义公司，微软真有你的~~，注意体会思想，下一章实验要用到  

## 第十四章 端口

1. 与CPU通过总线相连的有很多芯片，而这些芯片都控制有寄存器，从CPU的角度看，这些寄存器就是端口，可以将这些寄存器抽象(想象)统一成一块端口地址空间(还有一块内存地址空间，对于存储器来讲)  
2. 注意端口的读写要求以及读写的过程，CPU可以直接读写内部的寄存器/内存单元/端口，与访问内存的过程相似  
3. 了解CMOS RAM芯片的组成以及如何通过两个端口(70H/71H)与其交互，注意shl/shr指令  
4. 实验14：对于循环/递归里的变量，如果是有规律变化最好，可以直接add/sub固定的数值；对于不规则变化的变量，可以将其全部保存至数据段，如此便实现了规则变化，每次读取后加一即可  

## 第十五章 外中断

1. CPU通过相关芯片 [PC的接口卡和主板上有各种接口芯片] 的端口与外设进行联系，当CPU的内部或外部有需要处理的事情发生时，将产生中断信息，引发中断过程，注意两种外中断源的中断过程 [几乎所有外设引发的中断都是可屏蔽中断，响应与否取决于IF位]  
2. 以键盘输入为例，理清外中断的过程 [键盘中有一个芯片，会对每一个按键的开关状态进行扫描并产生扫描码，按下一个键会产生通码，松开会产生断码，类似于开闸放水，闸往下就出水，松开闸就止住了水；扫描码送进主板上相关接口芯片的端口，该芯片通过数据总线将中断信息传进CPU，根据IF位引发中断过程并转去执行相应的中断例程；对键盘来说，BIOS提供了相应中断例程，会先去检查扫描码，若是字符键，则连同其ASCII码送入BIOS键盘缓冲区，按规则存放，若是控制键/切换键，将其转换为状态字节写入内存中记录键盘状态的字节，类似于标志寄存器，每一位都有其含义]  
3. 学会编写和安装"int 9"中断例程，注意8086CPU提供的几大类指令(P285)  

## 第十六章 直接定址表

1. "带冒号的标号只能表示地址，而不带冒号的标号不光可以当地址使用，还可以直接查看里面的内容"，数据标号标记了地址及之后每一个单元的长度，地址标号只能在代码段中使用，不能在数据段或栈段中使用，在编译阶段编译器将数据标号替换成偏移地址，段地址应该是推断出来的？"如果要在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段同一个段寄存器联系起来；同时段寄存器不一定会真的存放该段的地址，在程序中仍需使用指令对段寄存器进行设置"；形如"a dw 1, 2, 3, 4"的语句与高级语言里的数组"int a[4] = {1, 2, 3, 4}"相似，a是数组首地址，dw是数组类型(数据长度)，后面跟上连续的同一类型的数据，但是汇编里的a有两层含义，另一层含义在高级语言里的"int"有所体现？之后每个单元的长度都是int型  
   > "https://blog.csdn.net/ScottePerk/article/details/115283056?utm_medium=distributepc_aggpage_search_resultnone-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-115283056-null-null.pc_agg_new_rankutm_term=%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%86%92%E5%8F%B7&spm=1000.2123.3001.4430"  
2. 可以将标号当作数据来定义，编译器将其所表示的地址当作数据的值，若占一个字单元则记录偏移地址，占两个字单元则同时记录偏移地址和段地址，注意offset/seg操作符的使用  
3. 注意直接定址表的应用及其意义，以空间换时间，查表映射出结果，类似于函数(子程序)指针数组  
4. 实验16：属性字节里的前景颜色，有十六种是因为加上了高亮，见下；注意table里的sub1/sub2等在编译时就已经替换成了地址，但是将其作为中断例程安装后的地址与已有地址不同，因此在执行中断例程时，根据直接定址表映射到的地址肯定不是当前子程序所在的地址，会出错  
   > "https://www.cnblogs.com/Master-Sun/p/10085579.html"  

## 第十七章 使用BIOS进行键盘输入和磁盘读写

1. 键盘缓冲区是用环形队列结构管理的内存区；在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即可以用栈的方式来管理字符串的存储空间；这些都是数据结构的应用体现  
2. 注意int9中断例程对键盘输入的处理过程以及int16H中断例程读取键盘缓冲区的过程，注意二者的相互配合使用及使用时机  
3. 磁盘包括软盘和硬盘，注意磁盘控制器/面号/磁道号/扇区号/驱动器号等概念以及应用int13H中断例程对磁盘进行读写  
4. 实验17：用到了与内存地址空间/端口地址空间相同的思想，用面号、磁道号、扇区号来访问具体某一个空间不太方便，于是将磁盘所以空间抽象，统一赋予逻辑扇区编号，用户给出一个参数即可，内部再运算出真正需要的三个参数  

## 程序设计 2

1. 思路：首先，核心程序肯定是要加载到07C00H处引导程序的位置上；①通电开机启动后int19H会自动从磁盘读取程序到内存，②一断电内存里的东西全部消失，综上，肯定先要把核心程序通过安装程序写到磁盘中，然后退出关机，再次开机启动后就会去将磁盘里的核心程序自动加载到内存里开始执行；因为①核心程序超过1个扇区的容量，②int19H例程只读取1号扇区的内容，所以在1号扇区只能写一个引导程序，其余扇区写核心程序，之后引导程序首先被加载到07C00H开始执行，因此其中肯定要有将核心程序加载进内存的程序段(本来还在想为什么不能把核心程序直接写到内存里，但是肯定要经过一次断电关机啊！！你放内存里不直接丢了；所以就断电前安装，通电启动后去07C00H处开始执行)；最后思路就比较明晰了，主程序里就两部分，为了可读性可以分别编写调用两个子程序，一个往1号扇区里编写引导程序，另一个往其余扇区里编写核心程序……~~冲冲冲！！！~~  
   > "https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" 优雅，实在是太优雅了?  
   - 没想到要清理缓冲区  
   - 程序组织混乱，没有做好结构模块化设计  

## 研究实验

1. 通过汇编指令结尾处的RET指令可以推知C语言将函数实现为汇编语言中的子程序  
2. 使用存储空间(寄存器&内存空间)需要指出两个信息：
   - 存储空间所在/是哪个
   - 存储空间有多大的类型消息  
     - 对于寄存器而言，只用给出寄存器名称即可，从名称中可推知类型信息(8位or16位)
     - 对于内存空间来说就需要给出首地址("a")及存储数据的类型("int")了，i.e: int a;  
3. "* (char far * )(0x20001000+_BX)=*(char *)_AX"这句的后半部分被编译成汇编码为"MOV BX, AX//MOV AL, [BX]"，可以看到AX寄存器中的值先是被当成地址来解释，最后被解释成了即将被赋给等式左边的值，其实本质就是解引用AX，从地址变成了值  
4. "XOR CX, CX"是8086CPU的一条异或运算指令，目的是将CX各位都置为0，同"MOV CX, 0"，但是效率更高；利用对同一个数异或运算两次将还原的特性可以进行加密解密
5. "push bp/mov bp, sp"以及转换成汇编码后利用bp加减相应的值去对应局部变量可看出，因为sp作为栈顶指针可能是一直在变的(如果定义了局部变量，便会有"SUB SP, 6"类似的指令)，因此才会将sp的值赋给bp，再去利用bp加减相应的值模拟在栈中上下移动的效果去指向局部变量；所以在当前函数域中若用到局部变量直接利用bp定位即可，而全局变量则是在同一个段地址的内存中；每个main函数开头push bp很显然就是因为下面要用到bp寄存器，保存现场，最后pop还原现场  
6. 在题干里的情况下，函数的返回值/malloc申请空间的首地址存放在AX寄存器中  
7. 之前我们看到，m.exe中调用main函数的call指令的偏移地址为011a，用debug加载c0s.exe，从相同位置开始向后查看10条指令，在m.exe中，call 01fa调用了main函数；在c0s.exe中，相同位置也有一次调用，但是因为没有main函数，连接器找不到main的位置，直接指向了下一条指令
原文链接：https://blog.csdn.net/bannerkiller/article/details/106929073
也就是说tc.exe把c0s.obj与用户.obj相连接，若用户.obj里没有main函数，那么本应在c0s.obj文件中call xxxx(main函数地址)的指令将直接指向下一条指令，否则就直接call main函数的地址  
----------------至此，你应该通过Turbo C下C0S.OBJ文件对.exe文件的运行过程有了初步的了解，并且在TC下通过改写C0S.OBJ可以不用main函数编程了?(注意是TC下的C0S.OBJ文件必须要main，否则就会报错，无法成功link，但是换成其他的就不一定了，比如LINK.EXE就可以成功link没有mian函数的obj文件)-----
1. VMware Workstation 15 WinXP系统(Guest OS)内的turbo c GUI页面不能用鼠标操作，通过F1~F10完成功能的切换，但是会与Host发生键位冲突，可在Guest里按"Fn+F1~F10"  
2. wcwcwcwcwcwcwcwcwcw通了通了，学C语言的时候只告诉你局部变量离开当前作用域就会"消失"，为什么呢？？因为被还原现场了呀！！！在函数的最开始push以保存bp的值是为了防止寄存器冲突，接下来将sp栈顶指针的值赋给bp是因为接下来可能会定义一些局部变量，而局部变量会压到"函数栈"中，此时sp便会随之变化，最后定义/声明的局部变量会被压到栈底，接着继续往上，比如"int b1, b2, b3"，b3最后定义，因此被压到栈底(别忘了是在地址较大处)，b1在最顶上(别忘了是在地址较小处，联系栈在内存中的实现)；最后到达函数末尾要RET回去了，此时将原来bp的值再赋回给sp，栈顶瞬间降到了定义局部变量之前，也可以说有了pop的效果(pop不是真的pop弹出去，只是栈顶指针往下，会被后来将要压入栈的东西覆盖掉而已)，也就是一到函数末尾就把局部变量都给pop掉了！！再"pop bp"以还原现场，最后直接RET回去  
3. main函数通过将对应的参数压栈来给子函数传递参数，并且在函数返回后通过POP操作将参数退栈。showchar通过SS:BP寻址在栈中取得对应的参数
4. 猜测：程序里要是冷不丁来一句"mov xx, [xxx]"，变成汇编码之后是DS:[xxx] (全局变量) or SS:[XXX] (局部变量) 估计是编译器干的工作，编译器把标识符都记下来，然后根据是局部还是全局变量再进行转换  
5. 疑问：如何函数不提前声明会报错"type mismatch to redeclaration + 函数名"  
6. 如果你在定义的子函数里没有用到声明时的某个参数或者是函数体内部定义的某个局部变量，那么编译后最终压到栈里的只要用到的参数及局部变量！！！  
7. X86CPU turbo C环境下，**要用到的**函数参数及紧随其后的局部变量，以从右到左，即函数中的最右边的参数/变量声明或定义处最右边的变量最先入栈  
8. 最后一个试验牵扯到printf函数(可变参数函数)的原理  
   > 可参考 "https://www.cnblogs.com/cpoint/p/3368993.html"